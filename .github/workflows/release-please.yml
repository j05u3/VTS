name: Release Please

on:
  push:
    branches:
      - main

# Required permissions for release-please to create PRs and releases
permissions:
  contents: write          # Create releases and tags
  pull-requests: write     # Create and update pull requests
  issues: write            # Create and manage labels

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.release.outputs.version }}
      pr: ${{ steps.release.outputs.pr }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  # Check if this push is from a merged release PR
  check-release-merge:
    runs-on: ubuntu-latest
    outputs:
      is_release_merge: ${{ steps.check.outputs.is_release_merge }}
      version: ${{ steps.check.outputs.version }}
      tag_name: ${{ steps.check.outputs.tag_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Check if this is a release merge
        id: check
        run: |
          # Get the commit message of the current commit
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          echo "Commit message: $COMMIT_MSG"
          
          # Check if this is a release commit (merged release PR)
          if [[ "$COMMIT_MSG" =~ ^chore:\ release\ main\ \(\#[0-9]+\)$ ]]; then
            echo "is_release_merge=true" >> $GITHUB_OUTPUT
            
            # Read version from manifest file
            VERSION=$(cat .release-please-manifest.json | grep -o '"[^"]*"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
            TAG_NAME="v$VERSION"
            
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "Detected release merge for version: $VERSION"
          else
            echo "is_release_merge=false" >> $GITHUB_OUTPUT
            echo "Not a release merge commit"
          fi

  # Create tag for merged release PR
  create-release-tag:
    needs: [check-release-merge]
    runs-on: ubuntu-latest
    if: ${{ needs.check-release-merge.outputs.is_release_merge == 'true' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TAG_NAME="${{ needs.check-release-merge.outputs.tag_name }}"
          echo "Creating tag: $TAG_NAME"
          
          git tag "$TAG_NAME"
          git push origin "$TAG_NAME"
          
          echo "âœ… Created and pushed tag: $TAG_NAME"

  # This job runs when release-please creates a new release OR when a release PR is merged
  build-and-release:
    needs: [release-please, check-release-merge, create-release-tag]
    runs-on: macos-15
    if: ${{ always() && (needs.release-please.outputs.release_created == 'true' || needs.check-release-merge.outputs.is_release_merge == 'true') }}
    
    env:
      APP_NAME: "VTS"
      BUNDLE_ID: "com.voicetypestudio.app"
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Set version variables
        id: version
        run: |
          if [ "${{ needs.release-please.outputs.release_created }}" = "true" ]; then
            # Use release-please outputs
            VERSION="${{ needs.release-please.outputs.version }}"
            TAG_NAME="${{ needs.release-please.outputs.tag_name }}"
          else
            # Use check-release-merge outputs  
            VERSION="${{ needs.check-release-merge.outputs.version }}"
            TAG_NAME="${{ needs.check-release-merge.outputs.tag_name }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          echo "Tag: $TAG_NAME"
          
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.2'
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Make build script executable
        run: chmod +x scripts/build-dmg.sh
      
      - name: Build, Sign, and Notarize DMG
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APP_NAME: ${{ env.APP_NAME }}
          BUNDLE_ID: ${{ env.BUNDLE_ID }}
          GITHUB_ACTIONS: true
          GITHUB_REF: refs/tags/${{ steps.version.outputs.tag_name }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: ./scripts/build-dmg.sh

      - name: Download Sparkle Tools and Sign DMG
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          VERSION: ${{ steps.version.outputs.version }}
          APP_NAME: ${{ env.APP_NAME }}
        run: |          
          echo "ðŸ” Signing DMG with Sparkle private key..."
          
          # Create temporary directory for Sparkle tools
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"
          
          # Download Sparkle tools
          SPARKLE_VERSION="2.6.4"
          SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          curl -L -o sparkle.tar.xz "$SPARKLE_URL"
          tar -xf sparkle.tar.xz
          
          # Create private key file
          echo "$SPARKLE_PRIVATE_KEY" > private_key
          
          # Sign the DMG and generate signature
          DMG_PATH="${GITHUB_WORKSPACE}/${APP_NAME}-${VERSION}-Universal.dmg"
          if [[ -f "$DMG_PATH" ]]; then
            # Generate signature
            SIGNATURE=$(./bin/sign_update "$DMG_PATH" private_key)
            echo "Generated signature: $SIGNATURE"
            
            # Save signature to file for the appcast
            echo "$SIGNATURE" > "${GITHUB_WORKSPACE}/${APP_NAME}-${VERSION}-Universal.dmg.sig"
            
            # Also create a JSON file with release metadata for GitHub Pages
            cat > "${GITHUB_WORKSPACE}/release-metadata.json" << EOF
          {
            "version": "${VERSION}",
            "dmg_name": "${APP_NAME}-${VERSION}-Universal.dmg",
            "sparkle_signature": "$SIGNATURE",
            "release_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
            
            echo "âœ… Successfully signed DMG with Sparkle signature"
          else
            echo "âŒ DMG file not found: $DMG_PATH"
            exit 1
          fi
          
          # Cleanup
          cd "$GITHUB_WORKSPACE"
          rm -rf "$TEMP_DIR"

      - name: Upload Release Artifacts
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag_name }}
          files: |
            ${{ env.APP_NAME }}-${{ steps.version.outputs.version }}-Universal.dmg
            ${{ env.APP_NAME }}-${{ steps.version.outputs.version }}-Universal.dmg.sig
            checksums.txt
            release-metadata.json
          token: ${{ secrets.GITHUB_TOKEN }}
        
      - name: Trigger GitHub Pages Update
        if: success()
        run: |
          echo "ðŸŽ‰ Release ${{ steps.version.outputs.tag_name }} has been published!"
          echo "ðŸ“¡ GitHub Pages will automatically update the appcast feed."
          echo "ðŸ”— Appcast URL: https://j05u3.github.io/VTS/appcast.xml"
