name: Build and Release macOS App

on:
  push:
    tags: ['v*']

env:
  APP_NAME: "VTS"
  BUNDLE_ID: "com.voicetypestudio.app"

permissions:
  contents: write
  
jobs:
  build:
    runs-on: macos-15
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history and tags
      
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.2'
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Make build script executable
      run: chmod +x scripts/build-dmg.sh
    
    - name: Build, Sign, and Notarize DMG
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APP_NAME: ${{ env.APP_NAME }}
        BUNDLE_ID: ${{ env.BUNDLE_ID }}
        GITHUB_ACTIONS: true
        GITHUB_REF: ${{ github.ref }}
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: ./scripts/build-dmg.sh

    - name: Extract version info
      id: get_version
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION_NUMBER=${VERSION#v}  # Remove 'v' prefix
        
        # Get the previous tag for comparison
        PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "^${VERSION}$" | head -n1)
        if [ -z "$PREVIOUS_TAG" ]; then
          PREVIOUS_TAG="v0.2.2"  # Fallback for first release
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
        echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
        echo "Building version: $VERSION_NUMBER"
        echo "Previous tag: $PREVIOUS_TAG"

    - name: Download Sparkle Tools and Sign DMG
      env:
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        VERSION_NUMBER: ${{ steps.get_version.outputs.version_number }}
        APP_NAME: ${{ env.APP_NAME }}
      run: |          
        echo "ğŸ” Signing DMG with Sparkle private key..."
        
        # Create temporary directory for Sparkle tools
        TEMP_DIR=$(mktemp -d)
        echo "ğŸ“ Created temp directory: $TEMP_DIR"
        cd "$TEMP_DIR"
        
        # Download Sparkle tools
        SPARKLE_VERSION="2.6.4"
        SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
        echo "ğŸ“¥ Downloading Sparkle tools from: $SPARKLE_URL"
        
        if ! curl -L -o sparkle.tar.xz "$SPARKLE_URL"; then
          echo "âŒ Failed to download Sparkle tools"
          exit 1
        fi
        
        echo "ğŸ“¦ Extracting Sparkle tools..."
        if ! tar -xf sparkle.tar.xz; then
          echo "âŒ Failed to extract Sparkle tools"
          echo "ğŸ“„ Archive contents:"
          tar -tf sparkle.tar.xz || echo "Cannot list archive contents"
          exit 1
        fi
        
        echo "ğŸ“‚ Contents after extraction:"
        ls -la
        
        # Check for bin directory and sign_update tool
        if [[ ! -d "bin" ]]; then
          echo "âŒ bin directory not found after extraction"
          echo "ğŸ“‚ Available directories:"
          find . -type d -name "*" | head -10
          exit 1
        fi
        
        if [[ ! -f "bin/sign_update" ]]; then
          echo "âŒ sign_update tool not found in bin directory"
          echo "ğŸ“‚ Contents of bin directory:"
          ls -la bin/
          exit 1
        fi
        
        # Make sign_update executable
        chmod +x bin/sign_update
        
        # Create private key file
        echo "$SPARKLE_PRIVATE_KEY" > private_key
        
        # Sign the DMG and generate signature
        DMG_PATH="${GITHUB_WORKSPACE}/${APP_NAME}-${VERSION_NUMBER}-Universal.dmg"
        echo "ğŸ” Looking for DMG at: $DMG_PATH"
        
        if [[ -f "$DMG_PATH" ]]; then
          echo "âœ… DMG file found, generating signature..."
          
          # Generate signature with error handling (using correct syntax)
          if ! SIGNATURE=$(./bin/sign_update -p --ed-key-file private_key "$DMG_PATH"); then
            echo "âŒ Failed to generate signature"
            echo "ğŸ”§ Debugging info:"
            file "$DMG_PATH"
            ls -la "$DMG_PATH"
            ./bin/sign_update --help || echo "No help available"
            exit 1
          fi
          
          echo "Generated signature: $SIGNATURE"
          
          # Validate signature is not empty
          if [[ -z "$SIGNATURE" ]]; then
            echo "âŒ Generated signature is empty"
            exit 1
          fi
          
          # Save signature to file for the appcast
          echo "$SIGNATURE" > "${GITHUB_WORKSPACE}/${APP_NAME}-${VERSION_NUMBER}-Universal.dmg.sig"
          
          # Also create a JSON file with release metadata for GitHub Pages
          cat > "${GITHUB_WORKSPACE}/release-metadata.json" << EOF
        {
          "version": "${VERSION_NUMBER}",
          "dmg_name": "${APP_NAME}-${VERSION_NUMBER}-Universal.dmg",
          "sparkle_signature": "$SIGNATURE",
          "release_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
          
          echo "âœ… Successfully signed DMG with Sparkle signature"
        else
          echo "âŒ DMG file not found: $DMG_PATH"
          echo "ğŸ“‚ Available files in workspace:"
          ls -la "$GITHUB_WORKSPACE"/*.dmg || echo "No DMG files found"
          exit 1
        fi
        
        # Cleanup
        cd "$GITHUB_WORKSPACE"
        rm -rf "$TEMP_DIR"

    - name: Update Release with Assets
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.get_version.outputs.version }}
        name: ${{ env.APP_NAME }} ${{ steps.get_version.outputs.version_number }}
        draft: false
        prerelease: false
        body: |
          ### Download
          - **Universal Binary (Intel + Apple Silicon)**: Download the DMG below
          - **Minimum macOS Version**: 14.0 (Sonoma)
          
          ### Installation
          1. Download the DMG file
          2. Open the DMG
          3. Drag ${{ env.APP_NAME }} to Applications folder
          4. Launch from Applications
          
          ### Verification
          This release is code-signed and notarized by Apple for security.
          
          ### Changes
          See the [commit history](https://github.com/${{ github.repository }}/compare/${{ steps.get_version.outputs.previous_tag }}...${{ steps.get_version.outputs.version }}) for detailed changes.
        files: |
          ${{ env.APP_NAME }}-${{ steps.get_version.outputs.version_number }}-Universal.dmg
          ${{ env.APP_NAME }}-${{ steps.get_version.outputs.version_number }}-Universal.dmg.sig
          checksums.txt
          release-metadata.json
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Update Appcast
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        VERSION_NUMBER: ${{ steps.get_version.outputs.version_number }}
        VERSION: ${{ steps.get_version.outputs.version }}
        APP_NAME: ${{ env.APP_NAME }}
      run: |
        echo "ğŸ”„ Updating appcast with new release..."
        
        # Read the Sparkle signature
        SIGNATURE_FILE="${APP_NAME}-${VERSION_NUMBER}-Universal.dmg.sig"
        if [[ -f "$SIGNATURE_FILE" ]]; then
          SPARKLE_SIGNATURE=$(cat "$SIGNATURE_FILE")
          echo "âœ… Found Sparkle signature"
        else
          echo "âŒ No Sparkle signature found"
          exit 1
        fi
        
        # Get DMG file size
        DMG_FILE="${APP_NAME}-${VERSION_NUMBER}-Universal.dmg"
        DMG_SIZE=$(stat -f%z "$DMG_FILE" 2>/dev/null || stat -c%s "$DMG_FILE")
        DMG_SIZE_MB=$(echo "scale=1; $DMG_SIZE / 1048576" | bc)
        
        # Get release information from GitHub API
        RELEASE_DATA=$(gh api repos/j05u3/VTS/releases/tags/${VERSION} --jq '{
          html_url,
          published_at,
          body,
          assets: [.assets[] | select(.name | endswith(".dmg") and (contains("Universal") or contains("universal"))) | {
            name,
            browser_download_url,
            size
          }]
        }')
        
        RELEASE_URL=$(echo "$RELEASE_DATA" | jq -r '.html_url')
        PUBLISHED_AT=$(echo "$RELEASE_DATA" | jq -r '.published_at')
        RELEASE_BODY=$(echo "$RELEASE_DATA" | jq -r '.body')
        DMG_DOWNLOAD_URL=$(echo "$RELEASE_DATA" | jq -r '.assets[0].browser_download_url')
        
        # Create/update releases data file
        mkdir -p docs/_data
        
        # Create a new release entry
        cat > "docs/_data/release_${VERSION_NUMBER}.json" << EOF
        {
          "version": "${VERSION_NUMBER}",
          "tag_name": "${VERSION}",
          "html_url": "${RELEASE_URL}",
          "published_at": "${PUBLISHED_AT}",
          "body": $(echo "$RELEASE_BODY" | jq -R -s .),
          "dmg_url": "${DMG_DOWNLOAD_URL}",
          "dmg_size": ${DMG_SIZE},
          "sparkle_signature": "${SPARKLE_SIGNATURE}"
        }
        EOF
        
        # Update the main releases data file
        if [[ ! -f "docs/_data/releases.json" ]]; then
          echo "[]" > docs/_data/releases.json
        fi
        
        # Add new release to the beginning of the array and keep only the latest 10
        NEW_RELEASE=$(cat "docs/_data/release_${VERSION_NUMBER}.json")
        jq ". = [$NEW_RELEASE] + . | .[0:10]" docs/_data/releases.json > docs/_data/releases_temp.json
        mv docs/_data/releases_temp.json docs/_data/releases.json
        
        # Clean up individual release file
        rm "docs/_data/release_${VERSION_NUMBER}.json"
        
        echo "âœ… Updated releases data file"
        
    - name: Commit and Push Appcast Updates
      env:
        VERSION_NUMBER: ${{ steps.get_version.outputs.version_number }}
      run: |
        echo "ğŸ“ Committing appcast updates..."
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add and commit the updated releases data
        git add docs/_data/releases.json
        
        if git diff --staged --quiet; then
          echo "ğŸ“ No changes to commit"
        else
          git commit -m "Update appcast with release ${VERSION_NUMBER} [skip ci]"
          git push origin main
          echo "âœ… Pushed appcast updates"
        fi
        
    - name: Success logs
      if: success()
      run: |
        echo "ğŸ‰ Release ${{ steps.get_version.outputs.version }} has been published!"
        echo "ğŸ“¡ GitHub Pages will automatically update the appcast feed."
        echo "ğŸ”— Appcast URL: https://j05u3.github.io/VTS/appcast.xml"
