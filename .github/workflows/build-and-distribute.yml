name: Build and Release macOS App

on:
  push:
    tags: ['v*']

env:
  APP_NAME: "VTS"
  BUNDLE_ID: "com.voicetypestudio.app"

permissions:
  contents: write
  
jobs:
  build:
    runs-on: macos-15
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history and tags
      
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.2'
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Make build script executable
      run: chmod +x scripts/build-dmg.sh
    
    - name: Build, Sign, and Notarize DMG
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APP_NAME: ${{ env.APP_NAME }}
        BUNDLE_ID: ${{ env.BUNDLE_ID }}
        GITHUB_ACTIONS: true
        GITHUB_REF: ${{ github.ref }}
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: ./scripts/build-dmg.sh

    - name: Extract version info
      id: get_version
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION_NUMBER=${VERSION#v}  # Remove 'v' prefix
        
        # Get the previous tag for comparison
        PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "^${VERSION}$" | head -n1)
        if [ -z "$PREVIOUS_TAG" ]; then
          PREVIOUS_TAG="v0.2.2"  # Fallback for first release
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
        echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
        echo "Building version: $VERSION_NUMBER"
        echo "Previous tag: $PREVIOUS_TAG"

    - name: Download Sparkle Tools and Sign DMG
      env:
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        VERSION_NUMBER: ${{ steps.get_version.outputs.version_number }}
        APP_NAME: ${{ env.APP_NAME }}
      run: |          
        echo "üîê Signing DMG with Sparkle private key..."
        
        # Create temporary directory for Sparkle tools
        TEMP_DIR=$(mktemp -d)
        echo "üìÅ Created temp directory: $TEMP_DIR"
        cd "$TEMP_DIR"
        
        # Download Sparkle tools
        SPARKLE_VERSION="2.6.4"
        SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
        echo "üì• Downloading Sparkle tools from: $SPARKLE_URL"
        
        if ! curl -L -o sparkle.tar.xz "$SPARKLE_URL"; then
          echo "‚ùå Failed to download Sparkle tools"
          exit 1
        fi
        
        echo "üì¶ Extracting Sparkle tools..."
        if ! tar -xf sparkle.tar.xz; then
          echo "‚ùå Failed to extract Sparkle tools"
          echo "üìÑ Archive contents:"
          tar -tf sparkle.tar.xz || echo "Cannot list archive contents"
          exit 1
        fi
        
        echo "üìÇ Contents after extraction:"
        ls -la
        
        # Check for bin directory and sign_update tool
        if [[ ! -d "bin" ]]; then
          echo "‚ùå bin directory not found after extraction"
          echo "üìÇ Available directories:"
          find . -type d -name "*" | head -10
          exit 1
        fi
        
        if [[ ! -f "bin/sign_update" ]]; then
          echo "‚ùå sign_update tool not found in bin directory"
          echo "üìÇ Contents of bin directory:"
          ls -la bin/
          exit 1
        fi
        
        # Make sign_update executable
        chmod +x bin/sign_update
        
        # Create private key file
        echo "$SPARKLE_PRIVATE_KEY" > private_key
        
        # Sign the DMG and generate signature
        DMG_PATH="${GITHUB_WORKSPACE}/${APP_NAME}-${VERSION_NUMBER}-Universal.dmg"
        echo "üîç Looking for DMG at: $DMG_PATH"
        
        if [[ -f "$DMG_PATH" ]]; then
          echo "‚úÖ DMG file found, generating signature..."
          
          # Generate signature with error handling (using correct syntax)
          if ! SIGNATURE=$(./bin/sign_update -p --ed-key-file private_key "$DMG_PATH"); then
            echo "‚ùå Failed to generate signature"
            echo "üîß Debugging info:"
            file "$DMG_PATH"
            ls -la "$DMG_PATH"
            ./bin/sign_update --help || echo "No help available"
            exit 1
          fi
          
          echo "Generated signature: $SIGNATURE"
          
          # Validate signature is not empty
          if [[ -z "$SIGNATURE" ]]; then
            echo "‚ùå Generated signature is empty"
            exit 1
          fi
          
          # Save signature to file for the appcast
          echo "$SIGNATURE" > "${GITHUB_WORKSPACE}/${APP_NAME}-${VERSION_NUMBER}-Universal.dmg.sig"
          
          # Also create a JSON file with release metadata for GitHub Pages
          cat > "${GITHUB_WORKSPACE}/release-metadata.json" << EOF
        {
          "version": "${VERSION_NUMBER}",
          "dmg_name": "${APP_NAME}-${VERSION_NUMBER}-Universal.dmg",
          "sparkle_signature": "$SIGNATURE",
          "release_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
          
          echo "‚úÖ Successfully signed DMG with Sparkle signature"
        else
          echo "‚ùå DMG file not found: $DMG_PATH"
          echo "üìÇ Available files in workspace:"
          ls -la "$GITHUB_WORKSPACE"/*.dmg || echo "No DMG files found"
          exit 1
        fi
        
        # Cleanup
        cd "$GITHUB_WORKSPACE"
        rm -rf "$TEMP_DIR"

    - name: Update Release with Assets
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.get_version.outputs.version }}
        name: ${{ env.APP_NAME }} ${{ steps.get_version.outputs.version_number }}
        draft: false
        prerelease: false
        files: |
          ${{ env.APP_NAME }}-${{ steps.get_version.outputs.version_number }}-Universal.dmg
          ${{ env.APP_NAME }}-${{ steps.get_version.outputs.version_number }}-Universal.dmg.sig
          checksums.txt
          release-metadata.json
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Update Appcast via GitHub API
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        VERSION_NUMBER: ${{ steps.get_version.outputs.version_number }}
        VERSION: ${{ steps.get_version.outputs.version }}
        APP_NAME: ${{ env.APP_NAME }}
      run: |
        echo "üîÑ Updating appcast via GitHub API..."
        
        # Read the Sparkle signature
        SIGNATURE_FILE="${APP_NAME}-${VERSION_NUMBER}-Universal.dmg.sig"
        if [[ -f "$SIGNATURE_FILE" ]]; then
          SPARKLE_SIGNATURE=$(cat "$SIGNATURE_FILE")
          echo "‚úÖ Found Sparkle signature"
        else
          echo "‚ùå No Sparkle signature found"
          exit 1
        fi
        
        # Get DMG file size
        DMG_FILE="${APP_NAME}-${VERSION_NUMBER}-Universal.dmg"
        if [[ ! -f "$DMG_FILE" ]]; then
          echo "‚ùå DMG file not found: $DMG_FILE"
          exit 1
        fi
        
        DMG_SIZE=$(stat -f%z "$DMG_FILE" 2>/dev/null || stat -c%s "$DMG_FILE")
        echo "üìè DMG size: $DMG_SIZE bytes"
        
        # Wait for release to be processed
        echo "‚è≥ Waiting for GitHub release to be processed..."
        sleep 15
        
        # Get release information with retry logic
        RETRY_COUNT=0
        MAX_RETRIES=6
        while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
          echo "üì° Fetching release data (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
          
          if RELEASE_DATA=$(gh api repos/j05u3/VTS/releases/tags/${VERSION} 2>/dev/null); then
            DMG_DOWNLOAD_URL=$(echo "$RELEASE_DATA" | jq -r '.assets[] | select(.name | endswith(".dmg") and contains("Universal")) | .browser_download_url // empty')
            
            if [[ -n "$DMG_DOWNLOAD_URL" && "$DMG_DOWNLOAD_URL" != "null" ]]; then
              echo "‚úÖ Found DMG download URL: $DMG_DOWNLOAD_URL"
              break
            fi
          fi
          
          echo "‚ö†Ô∏è DMG not yet available, retrying in 20 seconds..."
          sleep 20
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done
        
        if [[ $RETRY_COUNT -eq $MAX_RETRIES ]]; then
          echo "‚ùå Failed to get DMG download URL after $MAX_RETRIES attempts"
          exit 1
        fi
        
        # Extract other release data
        RELEASE_URL=$(echo "$RELEASE_DATA" | jq -r '.html_url')
        PUBLISHED_AT=$(echo "$RELEASE_DATA" | jq -r '.published_at')
        RELEASE_BODY=$(echo "$RELEASE_DATA" | jq -r '.body // ""')
        
        # Get current releases.json content from main branch
        echo "üì• Fetching current releases.json..."
        CURRENT_RELEASES=$(gh api repos/j05u3/VTS/contents/docs/_data/releases.json \
          --jq '.content' 2>/dev/null | base64 -d 2>/dev/null || echo "[]")
        
        # Create new release entry
        NEW_RELEASE=$(jq -n \
          --arg version "$VERSION_NUMBER" \
          --arg tag_name "$VERSION" \
          --arg html_url "$RELEASE_URL" \
          --arg published_at "$PUBLISHED_AT" \
          --arg body "$RELEASE_BODY" \
          --arg dmg_url "$DMG_DOWNLOAD_URL" \
          --argjson dmg_size "$DMG_SIZE" \
          --arg sparkle_signature "$SPARKLE_SIGNATURE" \
          '{
            version: $version,
            tag_name: $tag_name,
            html_url: $html_url,
            published_at: $published_at,
            body: $body,
            dmg_url: $dmg_url,
            dmg_size: $dmg_size,
            sparkle_signature: $sparkle_signature
          }')
        
        # Update releases array (add new release at beginning, keep only latest 10)
        UPDATED_RELEASES=$(echo "$CURRENT_RELEASES" | jq ". = [$NEW_RELEASE] + . | .[0:10]")
        
        # Get current file SHA for update
        CURRENT_SHA=$(gh api repos/j05u3/VTS/contents/docs/_data/releases.json \
          --jq '.sha' 2>/dev/null || echo "")
        
        # Prepare content for upload
        CONTENT_B64=$(echo "$UPDATED_RELEASES" | base64 | tr -d '\n')
        
        # Update file via GitHub API
        if [[ -n "$CURRENT_SHA" ]]; then
          # File exists, update it
          echo "üìù Updating existing releases.json..."
          gh api repos/j05u3/VTS/contents/docs/_data/releases.json \
            --method PUT \
            --field message="Update appcast with release ${VERSION_NUMBER} [skip ci]" \
            --field content="$CONTENT_B64" \
            --field sha="$CURRENT_SHA" \
            --field branch="main"
        else
          # File doesn't exist, create it
          echo "üìù Creating new releases.json..."
          gh api repos/j05u3/VTS/contents/docs/_data/releases.json \
            --method PUT \
            --field message="Create appcast with release ${VERSION_NUMBER} [skip ci]" \
            --field content="$CONTENT_B64" \
            --field branch="main"
        fi
        
        echo "‚úÖ Successfully updated appcast via GitHub API"
        echo "üìã Release summary:"
        echo "   Version: ${VERSION_NUMBER}"
        echo "   DMG URL: ${DMG_DOWNLOAD_URL}"
        echo "   Size: $(echo "scale=1; $DMG_SIZE / 1048576" | bc) MB"
        echo "   Signature: ${SPARKLE_SIGNATURE:0:32}..."
        
    - name: Success logs
      if: success()
      run: |
        echo "üéâ Release ${{ steps.get_version.outputs.version }} has been published!"
        echo "üì° GitHub Pages will automatically update the appcast feed."
        echo "üîó Appcast URL: https://j05u3.github.io/VTS/appcast.xml"
