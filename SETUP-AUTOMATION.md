# Modern Release Automation Setup Guide

This guide explains how to set up the modern release automation stack for VTS, including Sparkle auto-updates and release-please automation.

## ğŸ¯ Overview

The new release system includes:
- **release-please**: Automated changelog and version management based on Conventional Commits
- **Sparkle**: Automatic updates for macOS app
- **GitHub Releases**: Direct appcast hosting for reliability
- **Semantic PR validation**: Enforces Conventional Commits format for PRs

## ğŸš€ Quick Setup

### 1. Generate Sparkle Keys
```bash
# Run from project root
./scripts/setup-sparkle.sh
```

### 2. Add GitHub Secrets
Go to your repository â†’ Settings â†’ Secrets and variables â†’ Actions â†’ New repository secret:
- **Name**: `SPARKLE_PRIVATE_KEY`
- **Value**: The private key generated by the setup script

**Important**: This secret is used during the release process to:
- Sign DMG files with EdDSA signatures for Sparkle verification
- Generate signature files (.dmg.sig) uploaded with releases
- Ensure secure update delivery to users

### 3. Verify Setup
- Verify appcast.xml will be generated at GitHub Releases
- Test the release workflow by creating a conventional commit PR

## ğŸ”§ How It Works

### Pull Request Flow
1. **Developer creates PR** with conventional commit title (e.g., `feat: add new feature`)
2. **Semantic PR validation** ensures title follows conventional commits format
3. **PR gets merged** to main branch
4. **release-please** analyzes conventional commits and creates a release PR
5. **Maintainer reviews** the auto-generated release PR with changelog
6. **Merge release PR** â†’ triggers automatic build, sign, notarize, publish, and appcast generation

### Conventional Commit Types
- `feat:` - New features (minor version bump)
- `fix:` - Bug fixes (patch version bump) 
- `feat!:` or `fix!:` - Breaking changes (major version bump)
- `docs:`, `style:`, `refactor:`, `test:`, `chore:` - No version bump
- `perf:` - Performance improvements (patch version bump)

### Release Process
1. **Commits analyzed** â†’ version bump determined
2. **CHANGELOG.md** automatically updated
3. **version.txt** updated with new version
4. **Release created** with DMG artifacts
5. **GitHub Releases** automatically updated with new appcast
6. **Users notified** of updates via Sparkle

## ğŸ“± User Experience

### Auto-Update Preferences
Users can control update behavior in the app:
- **Auto-install updates**: Download and install automatically
- **Check for updates, ask before installing**: Show notification, user confirms
- **Do not check for updates**: Manual updates only

### Update Flow
1. User opens VTS
2. Sparkle checks appcast for updates (if enabled)
3. Update notification shown (based on user preference)
4. User can install immediately or later
5. App restarts with new version

## ğŸ” Security

### Code Signing
- Updates are signed with EdDSA keys (more secure than DSA)
- Sparkle verifies signatures before installing
- Keys stored securely in GitHub Secrets

### Distribution
- DMG files notarized by Apple for security
- Hosted on GitHub Releases (trusted source)
- HTTPS for all communications

## ğŸ›ï¸ Configuration Files

### release-please-config.json
Controls release automation behavior:
- Release type: `simple` (uses CHANGELOG.md and version.txt)
- Changelog sections with emojis for better readability
- Version tag format: `v1.0.0`

### .release-please-manifest.json
Tracks current version (source of truth)

### Info.plist
Contains Sparkle configuration:
- `SUFeedURL`: Appcast URL
- `SUPublicEDKey`: Public key for signature verification
- Update check interval and behavior

## ğŸ› ï¸ Manual Operations

### Force Release
If you need to create a release outside the normal flow:
```bash
# Manually trigger the legacy release workflow
gh workflow run release.yml -f tag_name=v1.0.0
```

### Update Appcast URL
If you need to change the appcast URL or use a different hosting method:
1. Update `SUFeedURL` in `VTSApp/Info.plist`
2. Commit and create new release

### Reset Versioning
If you need to reset version tracking:
1. Edit `.release-please-manifest.json`
2. Update `version.txt`
3. Commit both files

### Manual Release Trigger
To manually trigger a release (for testing):
```bash
gh workflow run build-and-distribute.yml --ref main
```

## ğŸ“ˆ Benefits

### For Developers
- âœ… Automated changelog generation
- âœ… Consistent version management  
- âœ… No manual tag creation
- âœ… Automatic CI/CD triggers
- âœ… Conventional commit enforcement

### For Users
- âœ… Automatic updates (configurable)
- âœ… Secure, signed updates
- âœ… Rich release notes
- âœ… Multiple update preferences
- âœ… Background downloads

### For Maintainers
- âœ… Professional release process
- âœ… Detailed changelogs
- âœ… Semantic versioning compliance
- âœ… Automated security scanning
- âœ… Rollback capabilities

## ğŸ” Troubleshooting

### Sparkle Not Working
1. Check `SUFeedURL` in Info.plist points to correct appcast
2. Verify public key in Info.plist matches private key in GitHub Secrets
3. Ensure appcast is accessible (test URL in browser)
4. Check app console for Sparkle error messages
5. **Verify SPARKLE_PRIVATE_KEY secret is set** - without it, updates won't be signed
6. **Check release assets include .dmg.sig files** - these contain the Sparkle signatures

### release-please Not Creating PRs
1. Verify commits follow Conventional Commits format
2. Check that PR titles are semantic (amannn/action-semantic-pull-request should validate)
3. Look for failed workflow runs in GitHub Actions
4. Ensure release-please has write permissions

### Build Failures
1. Check all required secrets are set in repository
2. Verify Xcode version matches workflow requirements
3. Ensure code signing certificates are valid
4. Check if notarization credentials are correct

## ğŸ‰ Next Steps

After setup:
1. Create your first conventional commit PR
2. Test the semantic PR validation
3. Merge PR and watch release-please create a release PR
4. Merge release PR and verify automatic build/release
5. Test Sparkle updates in the app

The system is designed to be fully automated once configured. Your release process will become as simple as merging conventional commits!
